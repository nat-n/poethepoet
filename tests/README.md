# Poe the Poet Tests

Good test coverage is critical for poethepoet. This readme describes the patterns and conventions we use.

Tests are normally run via `poe test`, which accepts extra arguments for pytest. For example to run a specific test with increased verbosity:

```sh
poe test -vv tests/test_cli.py::test_documentation_of_task_named_args
```

A test project can be manually debugged by either changing into the test project directory or addressing it with `-C`:

```sh
poe poe -C tests/fixtures/scripts_project --help check-global-options
```

The `poe` task runs poe from inside the project as a poe task itself, which is useful for testing.

The `test-quick` task runs the whole test suite with the exception of tests known to be particularly slow or flaky.

## Test strategy

The main emphasis is on exercising whole features end-to-end, including edge cases either by calling `poe` or as a subprocess using the `run_poe_subproc` fixture, or calling the `PoeThePoet` app in-process via the `run_poe` fixture, which is much faster to run.

Some easily isolated internals such as parsing logic are also unit tested.

This strategy emphasises functional correctness and protection against regression, whilst allowing most internal APIs to be refactored freely.

## Organization

```text
tests/
|-- conftest.py            # common pytest fixtures
|-- completions/           # tests relating to shell completions
|   |-- conftest.py
|   |-- harness.py         # library implementing a test harness for zsh completion scripts
|   |-- test_shell_completion.py
|   `-- test_zsh_completion_harness.py
|-- env/                   # tests related to envfile parsing
|   `-- test_parse_env_file.py
|-- fixtures/              # example projects for tests to work with
|   |-- *_project/
|   `-- packages/          # python packages for use in tests
|       `-- poe_test_helpers/  # cli utils for use in test poe tasks
|-- helpers/               # unit tests for the poethepoet.helpers subpackage
|   |-- conftest.py
|   |-- command/
|   |   |-- test_ast.py
|   |   `-- test_command_parsing.py
|   `-- test_eventloop.py
|-- options/               # unit tests for the poethepoet.options
|   `-- test_options.py
|-- temp/                  # temp files generated by tests (git ignored)
```

- Files that define tests are named like `test_*.py`
- Given the functional focus, tests are primarily organised by domain rather than type
- Some domains are organised into a subdirectories with their own `conftest.py`

## Fixtures

- Sample projects are collected under `tests/fixtures` and named with a `_project` suffix, the `projects` pytest fixture registers these by convention, and is used by `poe_run` etc
- Task files can also be dynamically generated using the temp_pyproject generator
- `tests/fixtures/packages` contains python packages for use in tests
- Most fixtures are kept in `tests/conftest.py`, unless they are specialised to testing only one area
- Fixture projects should be kept scoped to a single domain of functionality to test; prefer adding a new fixture project over expanding an unrelated one.
- The `run_poe` fixture should be prefered for new functional tests for performance reasons, unless there is some aspect of the test that benefits from running the poe cli in its own project, in which case `run_poe_subproc` must be used. Running poe in a subprocess offers better isolation, and CLI semantics. `run_poe_main` may also be used to exercis the cli entrypoint within the current project.
- If a test requires creating an isolated venv then `use_venv`, `use_virtualenv`, `with_virtualenv_and_venv` can be used. These fixtures are slow so should be used sparingly.

## Debugging zsh completion

The `poe zsh-harness` task runs zsh completion scripts through a test harness that stubs zsh builtins and captures their behavior. This is useful for debugging completion issues without needing an interactive shell.

Create a test file with configuration comments, or pipe directly to stdin using `-`:

```sh
poe zsh-harness - << 'EOF'
# WORDS: poe greet --greeting hello
# CURRENT: 5
# MOCK _zsh_describe_tasks: greet:Greet someone
# MOCK _zsh_task_args: --greeting,-g\tstring\tThe greeting\t_\t_\n--name\tstring\tName to greet\t_\t_
EOF
```

This test harness:
1. Reads configuration from the input: `# WORDS`, `# CURRENT`, and `# MOCK` directives
2. Generates the real completion script by calling get_zsh_completion_script() (unless the input already contains a full script with #compdef or function _poe)
3. Runs it through zsh with:
  - Stubbed builtins (_arguments, _describe, _files) that capture what they receive
  - mock poe builtins that returns your # MOCK data
  - The words array and CURRENT set to simulate a specific completion scenario

The harness shows what state was entered, which builtins were called, and what arguments were passed.

## Pytest marks

The following pytest marks are used systematically:

- `@pytest.mark.slow`: is applied to tests that usually take more than a couple of seconds, such as tests that require setting up a venv
- `@pytest.mark.flaky`: is used to mark tests that are prone to race conditions, so may need to be retried
- `@pytest.mark.skipif`: is used if a test is not expected to be able to run in all environments, such as if it requires a certain an undeclared external dependency from the host

Some other pytest marks are also used in the standard way, such as `parameterize`, `usefixtures`, or `asyncio`

## Debugging the poetry extension

The poethepoet poetry extension is covered by some tests, but must also be manually tested if changed. The `install-poetry-plugin` task can help streamline this process.

## Test code quality

Test code must follow the same standards as application code, the following poe tasks can help:

- `poe format`: apply code formatting to the whole code base including tests
- `poe style`: check formatting rules on the whole code base including tests
- `poe lint`: check linting rules on the whole code base including tests
- `poe types`: apply the type checker on the whole code base including tests

## Temp and cleanup
- `tests/temp/` is used for venvs and captured output; `poe clean` removes it, along with all other generated files within the project.
